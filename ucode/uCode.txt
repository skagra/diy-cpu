// =============================================================================
// Init code
// =============================================================================

.label RESET
ZERO
uP0-INIT p0                                                          // Load the location  of p0 code into the control unit
CDATA/LD/FF | S/LD/CDATA                                             // Set the stack pointer 
                                                                     // Zero registers
CDATA/LD/0 | A/LD/CDATA | X/LD/CDATA | Y/LD/CDATA | STASHH/LD/CDATA | STASHL/LD/CDATA | ALUA/LD/CDATA | ALUB/LD/CDATA | ALUC<-0
PZ/LD | PN/LD | PC/LD | PV/LD | P/SRC-0                              // Zero P   
PC/RESET                                                             // Load the reset vector location in the PC
MAR<-PC | MBR<-MEM                                                   // Load the LSB of the reset vector
STASHL<-MBR | PC-INC                                                 // Store it in STASHL, and increase the PC
MAR<-PC | MBR<-MEM                                                   // Load the MSB of the reset vector
PCL<-STASHL                                                          // Move the LSB of the reset vector into the PC
PCH<-MBR                                                             // Move the MSB of the reset vector into the PC

// =============================================================================
// Fetch (uP0)
// =============================================================================

.label p0
MAR<-PC | PC-INC                                                     // Move the PC into MAR and increase the PC                        
IR<-MEM                                                              // Load the current op code from memory into the IR
uP1                                                                  // Separate cycle as we don't have a handle on the op code for decoding until the previous cycle is completed

// =============================================================================
// Addressing modes (uP1) 
// =============================================================================

// Absolute 
.mode ABS
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the LSB address at PC, and increase PC
STASHL<-MBR                                                          // Store the LSB in STASHL
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the MSB address at PC, and increase PC
MARL<-STASHL                                                         // Move the LSB into MARL
MARH<-MBR | uP2                                                      // Move the MSB int MARL and jump to uP2

// Abs index by X 
.mode ABSIDXX 
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the LSB of the index base then increase the PC
ALUA<-MBR                                                            // Move the LSB to ALUA
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the MSB of the index base  
ALUB<-X | ALUC<-0                                                    // Move X into ALUB and reset the carry flag
ALUOP-ADD | MARL<-ALU | CUP/SRC/ALU | uJMP/INV | uCJMP ABSX_DONE     // Add X and the LSB, store the result in MARL and check whether we've spanned a page boundary
ALUA<-MBR                                                            // Spanned a page boundary - move MSB to ALUA 
ALUOP-INC | MARH<-ALU | uP2                                          // Increase the MSB, store the result in MARH, then jump to uP2
.label ABSX_DONE
MARH<-MBR                                                            // Move the high order byte into the of the base address into the MARH
MBR<-MEM | uP2                                                       // Move the calculation result into the low byte of the MARH, then jump to uP2

// Abs index by Y 
.mode ABSIDXY
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the LSB of the index base then increase the PC
ALUA<-MBR                                                            // Move the LSB to ALUA
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the MSB of the index base  
Y/OUT/CDATA | ALUB/LD/CDATA | ALUC<-0                                // Move Y into ALUB and reset the carry flag
ALUOP-ADD | MARL<-ALU | CUP/SRC/ALU | uJMP/INV | uCJMP ABSY_DONE     // Add Y and the LSB, store the result in MARL and check whether we've spanned a page boundary
ALUA<-MBR                                                            // Spanned a page boundary - move MSB to ALUA 
ALUOP-INC | MARH<-ALU | uP2                                          // Increase the MSB, store the result in MARH, then jump to uP2
.label ABSY_DONE
MARH<-MBR                                                            // Move the high order byte into the of the base address into the MARH
MBR<-MEM | uP2                                                       // Move the calculation result into the low byte of the MARH, then jump to uP2

// Accumulator 
.mode ACC 
uP2 

// Immediate 
.mode IMM
MAR<-PC | PC-INC | uP2                                               // Move the PC into MAR and jump to uP2

// Implied 
.mode IMP 
uP2                                                                  // Jump directly to uP2

// Relative 
.mode REL
MAR<-PC | PC-INC | uP2                                               // Move the PC into MAR and jump to uP2
                                                                                                      
// X Indirect ADC ($44,X)
.mode XIND
MAR<-PC | MBR<-MEM | PC-INC                                          // Get the base index zero page location
ALUA<-MBR                                                            // Move it into ALUA
X/OUT/CDATA | ALUB/LD/CDATA | ALUC<-0                                // Move X into ALUB and clear carry
ALUOP-ADD | STASHL<-ALU                                              // Add X and the base index, store result in STASHL (ingoring any carry), this points to the ZP data we need
CDATA/LD/0 | CDATA/TO/CADDRH | MARH/LD/CADDRH                        // Zero out MARH as we are in ZP
MARL<-STASHL | MBR<-MEM                                              // Load the final LSB into STASHH
STASHH<-MBR
STASHL/OUT/CDATA | ALUA/LD/CDATA                                     // Inc base address to point to the final MSB
ALUOP-INC | MARL<-ALU                                                // and store the pointer in MARL
MBR<-MEM                                                             // Load the final MSB
MARH<-MBR                                                            // Copy final values into MAR
MARL<-STASHH | uP2

//  The zero page argument is added to Y to give the zero page address of the operand.  Addition wraps to zero page.  
// Indirect Y ADC ($44),Y
.mode INDY
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the ZP address of the index then increase the PC
STASHH<-MBR                                                          // Store the ZP address in STASHH
CDATA/LD/0 | CDATA/TO/CADDRH | MARH/LD/CADDRH                        // Zero out the MARH as we are in ZP
MARL<-STASHH | MBR<-MEM                                              // Get the low byte of index base
STASHL<-MBR                                                          // Store LSB in STASHL
ALUA<-STASHH                                                         // Zero page index address
ALUOP-INC | MARL<-ALU                                                // Increase it
MBR<-MEM                                                             // Get the second byte of index base 
STASHH<-MBR                                                          // Store it in STASHH
ALUA<-STASHL                                                         // Now we need to add Y
ALUB<-Y | ALUC<-0
ALUOP-ADD | STASHL<-ALU | CUP/SRC/ALU | uJMP/INV | uCJMP INDY_DONE   // No carry so done
ALUA<-STASHH                                                         // Carry so need to increase the MSB
ALUOP-INC | STASHH<-ALU                                                                    
.label INDY_DONE
MARH<-STASHH
MARL<-STASHL | uP2

// Zero 
.mode ZP
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the zero page address of the operand
MARL<-MBR                                                            // Move the address into the LSB of the MAR
CDATA/LD/0 | CDATA/TO/CADDRH | MARH/LD/CADDRH | uP2                  // Move zero into the MSB of the MAR

// Zero index X
.mode ZPIDXX
MAR<-PC | MBR<-MEM | PC-INC                                          // Read index base then increase the PC
ALUA<-MBR                                                            // Move index base to ALUA
ALUB<-X | ALUC<-0                                                    // Move X into ALUB and clear carry
ALUOP-ADD | MARL<-ALU                                                // Add X and the index base and store in MARL
CDATA/LD/0 | CDATA/TO/CADDRH | MARH/LD/CADDRH | uP2                  // Zero out MARH

// Zero index Y
.mode ZPIDXY
MAR<-PC | MBR<-MEM | PC-INC                                          // Read index base then increase the PC
ALUA<-MBR                                                            // Move index base to ALUA
ALUB<-Y | ALUC<-0                                                    // Move X into ALUB and clear carry
ALUOP-ADD | MARL<-ALU                                                // Add X and the index base and store in MARL
CDATA/LD/0 | CDATA/TO/CADDRH | MARH/LD/CADDRH | uP2                  // Zero out MARH

// <--- Addressing modes (uP1) 

// =============================================================================
// Op codes (uP2)
// =============================================================================

// -----------------------------------------------------------------------------
// Arithmetic
// -----------------------------------------------------------------------------

.opcode ADC
MBR<-MEM
ALUA<-MBR
ALUB<-A | ALUC<-PC
ALUOP-ADD | ALUR/OUT/CDATA | A/LD/CDATA | PZ/LD | PN/LD | PC/LD | PV/LD | P/SRC-ALU | uP0  

.opcode SBC
MBR<-MEM
ALUB<-MBR
ALUA<-A | ALUC<-PC
ALUOP-SUB | ALUR/OUT/CDATA | A/LD/CDATA | PZ/LD | PN/LD | PC/LD | PV/LD | P/SRC-ALU | uP0  

// -----------------------------------------------------------------------------
// Logical
// -----------------------------------------------------------------------------

.opcode AND
MBR<-MEM
ALUA<-MBR
ALUB<-A
ALUOP-AND | ALUR/OUT/CDATA | A/LD/CDATA | PZ/LD | PN/LD | P/SRC-ALU | uP0  

.opcode ORA
MBR<-MEM 
ALUA<-MBR
ALUB<-A
ALUOP-OR | ALUR/OUT/CDATA | A/LD/CDATA | PZ/LD | PN/LD | P/SRC-ALU | uP0  

.opcode EOR
MBR<-MEM
ALUA<-MBR
ALUB<-A
ALUOP-XOR | ALUR/OUT/CDATA | A/LD/CDATA | PZ/LD | PN/LD | P/SRC-ALU | uP0  

// -----------------------------------------------------------------------------
// Shifts and rotates
// -----------------------------------------------------------------------------

.opcode ASL
ALUA<-A                                                              
ALUOP-SHL | A<-ALU | PZ/LD | PN/LD | PC/LD | P/SRC-ALU | uP0                                     

.opcode LSR
ALUA<-A                                                             
ALUOP-SHR | A<-ALU | PZ/LD | PN/LD | PC/LD | P/SRC-ALU | uP0 

.opcode ROL
MBR<-MEM                                                          
ALUOP-ROTL | MBR<-ALU | PZ/LD | PN/LD | PC/LD | P/SRC-ALU  
MEM<-MBR | uP0 

.opcode ROR
MBR<-MEM                                                          
ALUOP-ROTR | MBR<-ALU | PZ/LD | PN/LD | PC/LD | P/SRC-ALU |
MEM<-MBR | uP0 

// -----------------------------------------------------------------------------
// Branch
// -----------------------------------------------------------------------------

// Positive
.opcode BPL  
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uJMP/INV | uNJMP BPL_TRUE                                            // If previous operation resulted in non-negative jump to BPL_TRUE
uP0                                                                  // Jump to uP0
.label BPL_TRUE
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// Negative
.opcode BMI     
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uNJMP BMI_TRUE                                                       // If previous operation resulted in negative jump to BMI_TRUE
uP0                                                                  // Jump to uP0
.label BMI_TRUE
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// Overflow clear
.opcode BVC     
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uJMP/INV | uVJMP BVC_TRUE                                            // If previous operation resulted in no overflow jump to BVC_TRUE
uP0                                                                  // Jump to uP0
.label BVC_TRUE
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// Overflow set
.opcode BVS     
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uVJMP BVS_TRUE                                                       // If previous operation resulted in overflow jump to BVS_TRUE
uP0                                                                  // Jump to uP0
.label BVS_TRUE
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// No carry
.opcode BCC     
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uJMP/INV | uCJMP BVC_BCC                                             // If previous operation resulted in no carry jump to BVC_BCC
uP0                                                                  // Jump to uP0
.label BVC_BCC
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// Carry
.opcode BCS     
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uCJMP BVC_BCS                                                        // If previous operation resulted in a carry jump to BVC_BCS
uP0                                                                  // Jump to uP0
.label BVC_BCS
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// Not zero
.opcode BNE     
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uJMP/INV | uZJMP BEQ_BNE                                             // If previous operation resulted in non-zero jump to BEQ_BNE
uP0                                                                  // Jump to uP0
.label BEQ_BNE
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// Zero
.opcode BEQ                                                         
MBR<-MEM                                                             // Read the offset from memory at MAR into MBR
uZJMP BEQ_TRUE                                                       // If previous operation resulted in zero jump to BEQ_TRUE
uP0                                                                  // Jump to uP0
.label BEQ_TRUE
MBR/OUT/CDATA | PC/ADD/CDATA | uP0                                   // Add the displacement to the PC 

// -----------------------------------------------------------------------------
// Compare
// -----------------------------------------------------------------------------

.opcode CMP
MBR<-MEM  
ALUB<-MBR 
ALUA<-A | ALUC<-1 
ALUOP-SUB | PZ/LD | PN/LD | PC/LD | P/SRC-ALU | uP0  

.opcode CPX
MBR<-MEM  
ALUB<-MBR 
ALUA<-X | ALUC<-1 
ALUOP-SUB | PZ/LD | PN/LD | PC/LD | P/SRC-ALU | uP0  

.opcode CPY
MBR<-MEM  
ALUB<-MBR 
ALUA<-Y | ALUC<-1 
ALUOP-SUB | PZ/LD | PN/LD | PC/LD | P/SRC-ALU | uP0  

// -----------------------------------------------------------------------------
// Inc and Dec
// -----------------------------------------------------------------------------

.opcode DEC
MBR<-MEM 
ALUA<-MBR
ALUOP-DEC | MBR<-ALU | PZ/LD | PN/LD | P/SRC-ALU 
MEM<-MBR | uP0 

.opcode INC
MBR<-MEM 
ALUA<-MBR
ALUOP-INC | MBR<-ALU | PZ/LD | PN/LD | P/SRC-ALU 
MEM<-MBR | uP0 

.opcode INX
ALUA<-X                                                              // Move X to ALUA and clear the carry bit
ALUOP-INC | X<-ALU | PZ/LD | PN/LD | P/SRC-ALU | uP0                 // Add one, store result in X and set P flags

.opcode DEX
ALUA<-X                                                              // Move X to ALUA and clear the carry bit
ALUOP-DEC | X<-ALU | PZ/LD | PN/LD | P/SRC-ALU | uP0                 // Subtract one, store result in X and set P flags

.opcode INY
ALUA<-Y                                                   
ALUOP-INC | Y<-ALU | PZ/LD | PN/LD | P/SRC-ALU | uP0 

.opcode DEY
ALUA<-Y                                                     
ALUOP-DEC | Y<-ALU | PZ/LD | PN/LD | P/SRC-ALU | uP0 

// -----------------------------------------------------------------------------
// Flags
// -----------------------------------------------------------------------------

.opcode CLC
P/SRC-0 | PC/LD | uP0

.opcode SEC
P/SRC-1 | PC/LD | uP0

// .opcode CLI
// .opcode SEI

.opcode CLV
P/SRC-0 | PV/LD | uP0

// TODO
.opcode CLD
uP0

// .opcode SED

// -----------------------------------------------------------------------------
// Jump and subroutine
// -----------------------------------------------------------------------------

.opcode JMP
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the LSB address at PC, and increase PC
STASHL<-MBR                                                          // Store the LSB in STASHL
MAR<-PC | MBR<-MEM                                                   // Read the MSB address at PC, 
PCL<-STASHL                                                          // Move the LSB into PCL
PCH<-MBR | uP0                                                       // Move the MSB into PCH

.opcode JSR
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the LSB of the target address
STASHL<-MBR                                                          // Store the LSB in STASHL
MAR<-PC | MBR<-MEM | PC-INC                                          // Read the MSB of the target address
STASHH<-MBR                                                          // Store the MSB in STASHH
MAR<-S |  MBR<-PCL                                                   // Push the LSB of the PC onto the stack 
MEM<-MBR | S/DEC
MAR<-S | MBR<-PCH                                                    // Push the MSB of the PC onto the stack
MEM<-MBR | S/DEC                                                                   
PCL<-STASHL                                                          // Move the stored target address into the PC
PCH<-STASHH | uP0

.opcode RTS
S/INC                                                                // Increment the stack pointer
MAR<-S | MBR<-MEM | S/INC                                            // Move the stack pointer into MAR, read the MSB of the return address from the stack and increase the stack pointer
PCH<-MBR                                                             // Move the MSB of the return address into PCH
MAR<-S | MBR<-MEM                                                    // Move the stack pointer int MAR, read the LSB of the returns from the stack
PCL<-MBR | uP0                                                       // Move the LSB of the return address into PCL

// -----------------------------------------------------------------------------
// Register load and store
// -----------------------------------------------------------------------------

.opcode LDA
MBR<-MEM                                                             // Read value at MAR 
A<-MBR | PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0                        // Move value into A, setting P flags as appropriate

.opcode STA
MBR<-A                                                               // Move A into MBR
MEM<-MBR | uP0                                                       // Write MBR to memory at MAR

.opcode LDX
MBR<-MEM                                                             // Read the value at MAR
X<-MBR |  PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0                       // Move value into X                            

.opcode STX
MBR<-X                                                               // Move X into MBR
MEM<-MBR | uP0   

.opcode LDY
MBR<-MEM                                                             // Read the value at MAR
Y<-MBR |  PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0                       // Move the value into Y

.opcode STY
MBR<-Y                                                               // Move Y into MBR
MEM<-MBR | uP0   

// -----------------------------------------------------------------------------
// Register transfer
// -----------------------------------------------------------------------------

.opcode TAX
A/OUT/CDATA | X/LD/CDATA | PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0       // Move A to X 

.opcode TXA
X/OUT/CDATA | A/LD/CDATA | PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0       // Move X to A

.opcode TAY
A/OUT/CDATA | Y/LD/CDATA | PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0                                        

.opcode TYA
Y/OUT/CDATA | A/LD/CDATA | PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0  

.opcode TXS
X/OUT/CDATA | S/LD/CDATA | uP0                                        // Move X to S

.opcode TSX
S/OUT/CDATA | PZ/LD | PN/LD | P/SRC-FLGCDATA | X/LD/CDATA | uP0

// -----------------------------------------------------------------------------
// Stack
// -----------------------------------------------------------------------------

.opcode PHA
MAR<-S | MBR<-A                                                      // Copy the stack pointer to MAR and A to MBR
MEM<-MBR | S/DEC | uP0                                               // Push A onto the stack decrementing the stack pointer

.opcode PLA
S/INC                                                                // Increment the stack pointer
MAR<-S | MBR<-MEM                                                    // Read the value from the top of the stack
A<-MBR | PZ/LD | PN/LD | P/SRC-FLGCDATA | uP0                                                         // And move it into A

// .opcode PHP

.opcode PLP
S/INC                                                                // Increment the stack pointer
MAR<-S | MBR<-MEM                                                    // Read the value from the top of the stack
MBR/OUT/CDATA | P/SRC-CDATA | PN/LD | PV/LD | PZ/LD PC/LD | uP0      // Set P from the value read from the stack

// -----------------------------------------------------------------------------
// Misc
// -----------------------------------------------------------------------------

.opcode NOP
uP0

.opcode BRK
HALT

// <--- Op codes (uP2)
