// Init code
.label RESET
ZERO
uP0-INIT p0
CDATA/LD/FF | S/LD/CDATA
CDATA/LD/0 | PCH/LD/CDATA | PCL/LD/CDATA | CDATA/TO/CADDRH | CDATA/TO/CADDRL | MARH/LD/CADDRH | MARL/LD/CADDRL | MBR/LD/CDATA 
CDATA/LD/0 | A/LD/CDATA | X/LD/CDATA | Y/LD/CDATA | STASHH/LD/CDATA | STASHL/LD/CDATA | ALUA/LD/CDATA | ALUB/LD/CDATA | ALUC<-0
PZ/LD | PN/LD | PC/LD | PV/LD | P/SRC-0

// Fetch instruction at PC into IR
.label p0
MAR<-PC | PC-INC | IR<-MEM 
uP1                                                              // Separate cycle as we don't have a handle on the op code for decoding until the previous cycle is complete

// Addressing modes

// Immediate mode
.mode IMM
MAR<-PC | PC-INC | uP2

// Relative mode
.mode REL
MAR<-PC | PC-INC | uP2

// Implied mode
.mode IMP 
uP2 

// Absolute mode 
.mode ABS
MAR<-PC | MBR<-MEM | PC-INC
STASHL<-MBR | MAR<-PC | MBR<-MEM | PC-INC
MARL<-STASHL  
MARH<-MBR | uP2

// Abs index by X mode
.mode ABSX 
MAR<-PC | MBR<-MEM | PC-INC                                      // Grab the LSB of the index base then increase the PC
MAR<-PC | MBR<-MEM | ALUA<-MBR | | PC-INC                        // Grab the MSB of the index base then move the LSB to ALUA
X/OUT/CDATA | ALUB/LD/CDATA | ALUC<-0                            // Move X into ALUB and reset the carry flag
ALUOP-ADD | MARL<-ALU | CUP/SRC/ALU | uJMP/INV | uCJMP ABSXDONE  // Add X and the LSB, store the result in MARL and check whether we've spanned a page boundar
ALUA<-MBR | ALUC<-0                                              // Spanned a page boundary - move MSB to ALUA 
ALUOP-INC | MARH<-ALU | uP2                                      // Increase the MSB, store the result in MARH, then jump to uP2
.label ABSXDONE
MARH<-MBR                                                        // Move the high order byte into the of the base address into the MARH
MBR<-MEM | uP2                                                   // Move the calcuation result into the low byte of the MARH

// Op codes
.opcode LDA
MBR<-MEM
A<-MBR | PZ/LD | PN/LD | P/SRC-CDATA | uP0

.opcode TAX
A/OUT/CDATA | X/LD/CDATA | uP0

.opcode TXA
X/OUT/CDATA | A/LD/CDATA | uP0

.opcode LDX
X<-MBR | uP0

.opcode LDY
Y<-MBR | uP0

.opcode STA
MBR<-A 
MEM<-MBR | uP0

.opcode JMP
PCL<-STASHL     
PCH<-MBR | uP0

.opcode INX
ALUA<-X
X<-ALU | ALUOP-INC | PZ/LD | PN/LD | P/SRC-ALU | uP0

.opcode BEQ
MBR<-MEM
uZJMP BEQ_TRUE
uP0
.label BEQ_TRUE
MBR/OUT/CDATA | PC/ADD/CDATA | uP0

.opcode PHA
MAR<-S | MBR<-A
MEM<-MBR | S/DEC | uP0

.opcode PLA
S/INC 
MAR<-S | MBR<-MEM
A<-MBR | uP0

.opcode JSR
MAR<-PC | MBR<-MEM | PC-INC                                                         // Grab the LSB of the target address
STASHL<-MBR                                                                         // Store the LSB in STASHL
MAR<-PC | MBR<-MEM | PC-INC                                                         // Grab the MSB of the target address
STASHH<-MBR                                                                         // Store the MSB in STASHH
S/OUT/CADDR | MARL/LD/CADDRL | MARH/LD/CADDRH | PCL/OUT/CDATA | MBR/LD/CDATA        // Push the LSB of the PC onto the stack 
MEM<-MBR | S/DEC
S/OUT/CADDR | MARL/LD/CADDRL | MARH/LD/CADDRH | PCH/OUT/CDATA | MBR/LD/CDATA        // Push the MSB of the PC onto the stack
MEM<-MBR | S/DEC                                                                   
STASHL/OUT/CDATA | PCL/LD/CDATA                                                     // Move the stored target address into the PC
STASHH/OUT/CDATA | PCH/LD/CDATA | uP0

.opcode RTS
S/INC
S/OUT/CADDR | MARL/LD/CADDRL | MARH/LD/CADDRH | MBR<-MEM | S/INC
MBR/OUT/CDATA | STASHH/LD/CDATA
STASHH/OUT/CDATA | PCH/LD/CDATA
S/OUT/CADDR | MARL/LD/CADDRL | MARH/LD/CADDRH | MBR<-MEM
MBR/OUT/CDATA | PCL/LD/CDATA | uP0

.opcode BRK
HALT


